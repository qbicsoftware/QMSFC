#     cat("ERROR1: ", ensembl, "\n")
#     Sys.sleep(1)
#     print("reconnecting...")
#     bo <- bo+1
#     print(bo)
#   } else
#     break
# }
# save(list=c("ensembl"), file="ensembl.Rdata")
file.copy("ensembl.Rdata",to = wd)
#load functions file
source(paste(wd,"/function.R",sep = ""))
##Experimental Design initially included 2 technical replicates that afterwards were combined for the analysis
##We used the QBiC codes corresponding to the first replicate of the peptides in the "Q0985_sample_preparations_20210430094501.tsv"
##BiocManager and r were previously updated to 3.12 AND 4.0.5, respectively.
##
rm(list = ls(all = TRUE)); graphics.off()
path <- getwd(); setwd(path)
path
setwd(path)
#load packages and functions, installation of some of them is quite time consuming
#e.g. devtools, pca3d and proteus
#To install proteus you might need rmarkdown and devtools if not yet installed
if (!requireNamespace("BiocManager", quietly = TRUE)) {
install.packages("BiocManager")
}
if (!require("rmarkdown")){
BiocManager::install("rmarkdown")
library("rmarkdown")
}
if (!require("devtools")){
BiocManager::install("devtools")
library("devtools")
}
if (!require("proteus")){
#In order to run examples or vignette code,
#additional packages with example data need to be installed:
devtools::install_github("bartongroup/proteusLabelFree")
devtools::install_github("bartongroup/proteusTMT")
devtools::install_github("bartongroup/proteusSILAC")
devtools::install_github("bartongroup/Proteus",
build_opts= c("--no-resave-data", "--no-manual"), build_vignettes=FALSE)
library("proteus")
}
if (!require("limma")){
BiocManager::install("limma")
library("limma")
}
if (!require("dendextend")){
BiocManager::install("dendextend")
library("dendextend")
}
if (!require("ggplot2")){
BiocManager::install("ggplot2")
library("ggplot2")
}
if (!require("reshape")){
BiocManager::install("reshape")
library("reshape")
}
if (!require("pca3d")){
BiocManager::install("pca3d")
library("pca3d")
}
if (!require("rgl")){
BiocManager::install("rgl")
library("rgl")
}
if (!require("biomaRt")){
BiocManager::install("biomaRt")
library("biomaRt")
}
if (!require("gplots")){
BiocManager::install("gplots")
library("gplots")
}
if (!require("genefilter")){
BiocManager::install("genefilter")
library("genefilter")
}
if (!require("RColorBrewer")){
BiocManager::install("RColorBrewer")
library("RColorBrewer")
}
if (!require("EnhancedVolcano")){
BiocManager::install("EnhancedVolcano")
library("EnhancedVolcano")
}
if (!require("xtable")){
BiocManager::install("xtable")
library("xtable")
}
#begin main analysis
mt <- data.frame(norms=c("p1n <- normalizeData(p1,norm.fun = normalizeMedian)",
"p1n <- normalizeData(p1,norm.fun = normalizeQuantiles)"),
filt = c(0,0,2,2,6,6))
##Experimental Design initially included 2 technical replicates that afterwards were combined for the analysis
##We used the QBiC codes corresponding to the first replicate of the peptides in the "Q0985_sample_preparations_20210430094501.tsv"
##BiocManager and r were previously updated to 3.12 AND 4.0.5, respectively.
##
rm(list = ls(all = TRUE)); graphics.off()
path <- getwd(); setwd(path)
path
calc_max_edges <- function(num_nodes) {
if (num_nodes == 0) {
return(0)
}
value <- 0
for (i in seq(1, num_nodes)) {
value <- value + i - 1
}
return(2*value + num_nodes)
}
options(digits = 22)
print(calc_max_edges(3))
print(calc_max_edges(4))
# print(calc_max_edges(3))
print(calc_max_edges(35))
print(calc_max_edges(377123))
print(calc_max_edges(200000))
4e+10
4e+1
4e+4
print(calc_max_edges(2000000)) #4e+10
library(tidyverse)
library(ggbeeswarm)
library(knitr)
library(gridExtra)
args <- commandArgs(trailingOnly = T)
odgi_extract_csv <- args[1]
vg_chunk_csv <- args[2]
extract_pdf <- args[3]
extract_csv <- args[4]
odgi_extract_csv <- "/home/heumos/git/odgi-paper/data/odgi_extract_time.csv"
odgi_extract <- read.delim(odgi_extract_csv, sep = ",", as.is = T, header = F, stringsAsFactors = F, strip.white = T)
colnames(odgi_extract) <- c("threads", "haps", "run", "time", "memory")
# time is in seconds
# memory is in kilobytes
odgi_extract$tool <- "odgi extract"
summary(odgi_extract)
vg_chunk_csv <- "/home/heumos/git/odgi-paper/data/vg_chunk_time.csv"
vg_chunk <- read.delim(vg_chunk_csv, sep = ",", as.is = T, header = F, stringsAsFactors = F, strip.white = T)
colnames(vg_chunk) <- c("threads", "haps", "run", "time", "memory")
vg_chunk$tool <- "vg chunk"
summary(vg_chunk)
extract <- rbind(odgi_extract, vg_chunk)
extract$threads <- factor(extract$threads, levels=unique(extract$threads))
extract$haps <- factor(extract$haps, levels=unique(extract$haps))
# extract$memory <- factor(extract$memory, levels=unique(extract$memory))
extract$memory <- as.numeric(extract$memory)/1000000
extract_64haps <- extract[extract$haps == 64,]
extract_64haps_m <- aggregate(cbind(memory,time) ~threads+haps+tool, data=extract_64haps, FUN=mean)
extract_16threads <- extract[extract$threads == 16,]
extract_16threads_m <- aggregate(cbind(memory,time) ~threads+haps+tool, data=extract_16threads, FUN=mean)
dodge <- position_dodge(width = 0.0)
et_p_t <- ggplot(extract_64haps_m, aes(x=threads, y=time, fill=tool, color = tool)) +
geom_violin(position = dodge) +
#geom_beeswarm(size=0.5) +
labs(x = "number of threads", y = "time in seconds") +
expand_limits(x = 0, y = 0) +
theme(legend.position = "none")
et_p_t
View(extract_64haps_m)
et_p_t <- ggplot(extract_64haps_m, aes(x=threads, y=time, fill=tool, color = tool)) +
geom_point() + geom_line() +
#geom_beeswarm(size=0.5) +
labs(x = "number of threads", y = "time in seconds") +
expand_limits(x = 0, y = 0) +
theme(legend.position = "none")
et_p_t
et_p_t <- ggplot(extract_64haps_m, aes(x=threads, y=time, fill=tool, color = tool, group=tool)) +
geom_point() + geom_line() +
#geom_beeswarm(size=0.5) +
labs(x = "number of threads", y = "time in seconds") +
expand_limits(x = 0, y = 0) +
theme(legend.position = "none")
et_p_t
eh_p_t <- ggplot(extract_16threads_m, aes(x=haps, y=time, fill=tool, color = tool, group=tool)) +
geom_point() + geom_line() +
#geom_beeswarm(size=0.5) +
labs(x = "number of haplotypes", y = "time in seconds") +
expand_limits(x = 0, y = 0) + theme(legend.direction = "horizontal") +
labs(color = "tool   ") +
labs(fill = "tool   ") +
theme(legend.title = element_text(size=15)) +
theme(legend.key.size = unit(0.4, 'cm'))
eh_p_t
eh_p_t <- ggplot(extract_16threads_m, aes(x=haps, y=time, fill=tool, color = tool, group=tool)) +
geom_point() + geom_line() +
#geom_beeswarm(size=0.5) +
labs(x = "number of haplotypes", y = "time in seconds") +
expand_limits(x = 0, y = 0) + theme(legend.direction = "horizontal") +
labs(color = "tool   ") +
labs(fill = "tool   ") +
theme(legend.title = element_text(size=15)) +
theme(legend.key.size = unit(1, 'cm'))
eh_p_t
eh_p_t <- ggplot(extract_16threads_m, aes(x=haps, y=time, fill=tool, color = tool, group=tool)) +
geom_point() + geom_line() +
#geom_beeswarm(size=0.5) +
labs(x = "number of haplotypes", y = "time in seconds") +
expand_limits(x = 0, y = 0) + theme(legend.direction = "horizontal") +
labs(color = "tool   ") +
labs(fill = "tool   ") +
theme(legend.title = element_text(size=15)) +
theme(legend.key.size = unit(0.4, 'cm'))
eh_p_t
get_legend <- function(a.gplot) {
tmp <- ggplot_gtable(ggplot_build(a.gplot))
leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
legend <- tmp$grobs[[leg]]
return(legend)
}
legend <- get_legend(eh_p_t)
eh_p_t <- eh_p_t + theme(legend.position = "none")
# collapse memory by run and take the mean
et_p_m <- ggplot(extract_64haps_m, aes(x=threads, y=memory, fill=tool, color = tool, group = tool)) +
geom_point() + geom_line() +
#geom_beeswarm(size=0.5) +
labs(x = "number of threads", y = "memory in gigabytes") +
expand_limits(x = 0, y = 0) +
theme(legend.position = "none")
et_p_m
eh_p_m <- ggplot(extract_16threads_m, aes(x=haps, y=memory, fill=tool, color = tool, group = tool)) +
geom_point() + geom_line() +
#geom_beeswarm(size=0.5) +
labs(x = "number of haplotypes", y = "memory in gigabytes") +
expand_limits(x = 0, y = 0) +
theme(legend.position = "none")
eh_p_m
grid.arrange(arrangeGrob(et_p_t, eh_p_t, nrow = 1), arrangeGrob(et_p_m, eh_p_m, nrow = 1), legend, nrow = 3, heights = c(1,1,0.1))
library(tidyverse)
library(ggbeeswarm)
library(knitr)
library(gridExtra)
library(R.devices)
args <- commandArgs(trailingOnly = T)
odgi_build_csv <- args[1]
vg_convert_csv <- args[2]
build_pdf <- args[3]
build_csv <- args[4]
#odgi_build_csv <- "/home/heumos/git/odgi-paper/data/odgi_build_threads_haps_time.csv"
odgi_build <- read.delim(odgi_build_csv, sep = ",", as.is = T, header = F, stringsAsFactors = F, strip.white = T)
colnames(odgi_build) <- c("threads", "haps", "run", "time", "memory")
# time is in seconds
# memory is in kilobytes
odgi_build$tool <- "odgi build"
odgi_build_csv <- "/home/heumos/git/odgi-paper/data/odgi_build_threads_haps_time.csv"
odgi_build <- read.delim(odgi_build_csv, sep = ",", as.is = T, header = F, stringsAsFactors = F, strip.white = T)
colnames(odgi_build) <- c("threads", "haps", "run", "time", "memory")
# time is in seconds
# memory is in kilobytes
odgi_build$tool <- "odgi build"
summary(odgi_build)
#vg_convert_csv <- "/home/heumos/git/odgi-paper/data/vg_convert_threads_haps_time.csv"
vg_convert <- read.delim(vg_convert_csv, sep = ",", as.is = T, header = F, stringsAsFactors = F, strip.white = T)
colnames(vg_convert) <- c("threads", "haps", "run", "time", "memory")
vg_convert$tool <- "vg convert"
summary(vg_convert)
vg_convert_csv <- "/home/heumos/git/odgi-paper/data/vg_convert_threads_haps_time.csv"
#vg_convert_csv <- "/home/heumos/git/odgi-paper/data/vg_convert_threads_haps_time.csv"
vg_convert <- read.delim(vg_convert_csv, sep = ",", as.is = T, header = F, stringsAsFactors = F, strip.white = T)
colnames(vg_convert) <- c("threads", "haps", "run", "time", "memory")
vg_convert$tool <- "vg convert"
summary(vg_convert)
construct <- rbind(odgi_build, vg_convert)
construct$threads <- factor(construct$threads, levels=unique(construct$threads))
construct$haps <- factor(construct$haps, levels=unique(construct$haps))
# construct$memory <- factor(construct$memory, levels=unique(construct$memory))
construct$memory <- as.numeric(construct$memory)/1000000
construct_64haps <- construct[construct$haps == 64,]
construct_64haps_m <- aggregate(cbind(memory,time) ~threads+haps+tool, data=construct_64haps, FUN=mean)
construct_16threads <- construct[construct$threads == 16,]
construct_16threads_m <- aggregate(cbind(memory,time) ~threads+haps+tool, data=construct_16threads, FUN=mean)
ct_p_t <- ggplot(construct_64haps, aes(x=threads, y=time, fill=tool, color = tool, group=tool)) +
geom_point() + geom_line() +
#geom_beeswarm(size=0.5) +
labs(x = "number of threads", y = "time in seconds") +
expand_limits(x = 0, y = 0) +
theme(legend.position = "none")
ct_p_t
ct_p_t <- ggplot(construct_64haps_m, aes(x=threads, y=time, fill=tool, color = tool, group=tool)) +
geom_point() + geom_line() +
#geom_beeswarm(size=0.5) +
labs(x = "number of threads", y = "time in seconds") +
expand_limits(x = 0, y = 0) +
theme(legend.position = "none")
ct_p_t
ch_p_t <- ggplot(construct_16threads,_m aes(x=haps, y=time, fill=tool, color = tool)) +
geom_violin(position = dodge) +
#geom_beeswarm(size=0.5) +
labs(x = "number of haplotypes", y = "time in seconds") +
expand_limits(x = 0, y = 0) + theme(legend.direction = "horizontal") +
labs(color = "tool   ") +
labs(fill = "tool   ") +
theme(legend.title = element_text(size=15)) +
theme(legend.key.size = unit(0.4, 'cm'))
ch_p_t
ch_p_t <- ggplot(construct_16threads,_m aes(x=haps, y=time, fill=tool, color = tool)) +
geom_violin(position = dodge) +
#geom_beeswarm(size=0.5) +
labs(x = "number of haplotypes", y = "time in seconds") +
expand_limits(x = 0, y = 0) + theme(legend.direction = "horizontal") +
labs(color = "tool   ") +
labs(fill = "tool   ") +
theme(legend.title = element_text(size=15)) +
theme(legend.key.size = unit(0.4, 'cm'))
ch_p_t <- ggplot(construct_16threads_m,aes(x=haps, y=time, fill=tool, color = tool, group=tool)) +
geom_point() + geom_line() +
#geom_beeswarm(size=0.5) +
labs(x = "number of haplotypes", y = "time in seconds") +
expand_limits(x = 0, y = 0) + theme(legend.direction = "horizontal") +
labs(color = "tool   ") +
labs(fill = "tool   ") +
theme(legend.title = element_text(size=15)) +
theme(legend.key.size = unit(0.4, 'cm'))
ch_p_t
get_legend <- function(a.gplot) {
tmp <- ggplot_gtable(ggplot_build(a.gplot))
leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
legend <- tmp$grobs[[leg]]
return(legend)
}
legend <- get_legend(ch_p_t)
ch_p_t <- ch_p_t + theme(legend.position = "none")
# collapse memory by run and take the mean
ct_p_m <- ggplot(construct_64haps_m, aes(x=threads, y=memory, fill=tool, color = tool, group = tool)) +
geom_point() + geom_line() +
#geom_beeswarm(size=0.5) +
labs(x = "number of threads", y = "memory in gigabytes") +
expand_limits(x = 0, y = 0) +
theme(legend.position = "none")
ch_p_m <- ggplot(construct_16threads_m, aes(x=haps, y=memory, fill=tool, color = tool, group = tool)) +
geom_point() + geom_line() +
#geom_beeswarm(size=0.5) +
labs(x = "number of haplotypes", y = "memory in gigabytes") +
expand_limits(x = 0, y = 0) +
theme(legend.position = "none")
ct_p_m
ch_p_m <- ggplot(construct_16threads_m, aes(x=haps, y=memory, fill=tool, color = tool, group = tool)) +
geom_point() + geom_line() +
#geom_beeswarm(size=0.5) +
labs(x = "number of haplotypes", y = "memory in gigabytes") +
expand_limits(x = 0, y = 0) +
theme(legend.position = "none")
ch_p_m
grid.arrange(arrangeGrob(ct_p_t, ch_p_t, nrow = 1), arrangeGrob(ct_p_m, ch_p_m, nrow = 1), legend, nrow = 3, heights = c(1,1,0.1))
skewness
### R code from vignette source 'omicade4.Rnw'
rm(list = ls(all = TRUE)) # clear all  variables
graphics.off()
trim <- function (x) gsub("^\\s+|\\s+$", "", x)
# install.packages("rstudioapi") # run this if it's your first time using it to install
library(rstudioapi) # load it
# the following line is for getting the path of your current open file
current_path <- getActiveDocumentContext()$path
# The next line set the working directory to the relevant one:
setwd(dirname(current_path ))
# you can make sure you are in the right directory
print(getwd())
wd <- getwd()
setwd(wd)
#### --------------FACS ####
setwd(paste (wd,'/lists_tsv/',sep=""))    # assumes this subfolder exists and contains the protein summaries
files_m <- dir()    # get the filenames
BG = NULL
for (i in 1:length(files_m))   # loop through files
{
fn = files_m[i];
print(fn)
d1 = read.table(fn,  header = T,sep = "\t",na.strings =c("","NaN"),quote=NULL,
stringsAsFactors=F,dec=".",fill=TRUE, as.is = T, check.names=FALSE)
d1$srt = d1$WID = d1$receptor = NULL
if(i==1)
{BG = d1}
else{
BG = merge(BG,d1, x.by = "receptor_esc", y.by ="receptor_esc")
}
}
setwd(wd)
write.table(BG, file = "all_facs.tmp.tsv", append = FALSE, quote = FALSE, sep = "\t",
eol = "\n", na = "NA", dec = ".", row.names = FALSE,  col.names = TRUE, qmethod = c("escape", "double"))
idx = grep("wk2",names(BG))
names(BG)[idx]
BG = BG[, -idx]
d1 = BG
names(d1) <- gsub("\\_wk1","", names(d1))
names(d1) <- gsub("X786_O","786_O", names(d1))
x = read.table('facs_exp_design_extended.csv',header=TRUE,sep="\t", as.is = TRUE, quote="", skip = 0, check.names=FALSE);
idx = grep ("wk2", x$sample_name)
x=x[-idx,]
x$sample_name <- gsub("\\_wk1","", x$sample_name)
x$comb_sn =  paste(x$cancer_type2, x$sample_name, sep=".")
names(d1) =  gsub("\\NCI_","", names(d1))
setdiff(names(d1), x$sample_name)
for ( i in 2:(dim(d1)[2])) # add abbreviations CO, BR...etc
{
idx = which(x$sample_name == names(d1)[i])
names(d1)[i] = x$comb_sn[idx]
}
names(d1)
row.names( d1 )  = d1$receptor_esc
d1$receptor_esc = NULL
names(d1) = gsub("\\_","", names(d1))
facs = d1
rownames(facs) <- gsub(" |_|-|\\.|/|,|\\(|)", "", rownames(facs))
rownames_to_remove <- rownames(facs)[grepl("AH|kappa",rownames(facs))]
rownames_to_remove_number <- which(row.names(facs) %in% rownames_to_remove)
facs <- facs[-rownames_to_remove_number,]
## correction of names in facs
names(facs)[names(facs) == "CO.MFIHCT15"] <- "CO.HCT15"
names(facs)[names(facs) == "LC.MFIH23"] <- "LC.H23"
names(facs)[names(facs) == "LE.HL60(TB)"] <- "LE.HL60"
names(facs)[names(facs) == "OV.NCI/ADRRES"] <- "OV.ADRRES"
names(facs)[names(facs) == "RE.786O"] <- "RE.7860"
names(facs)
write.table(facs, "FACS_no_ICS_April2022.tsv", sep = "\t")
####
################################################################
#### transcriptome ####
#td=read.table('transcriptome.tsv',header=TRUE,sep="\t", as.is = TRUE, quote="");
#tmp = td
#a = td[1:2,9:67]
#a=t(a)
xt = read.table('transcr_exp_design.tsv',header=TRUE,sep="\t", as.is = TRUE, quote="", skip = 0);
#xt$cancer =  sapply(strsplit(xt$cell_linet,"\\_"), "[[",1)
xt$clt =  sapply(strsplit(xt$cell_linet,"\\_"), "[[",2)
td2 = read.table('../Curate_ArrayData_April2022/GSE32474_series_matrix_curated.txt',header=TRUE,sep="\t", as.is = TRUE, skip = 0);
td=td2
nm = names(td)
kix =  sapply(strsplit(nm,"\\_"), "[[",1)
length(unique(kix))
kix = (intersect(kix, xt$code))
#row.names(td) = td$X
#td$X = NULL
names(td) =   sapply(strsplit(names(td),"\\_"), "[[",1)
td =subset(td, select = kix)
head(td)
for ( i in 1:(dim(td)[2])) # add abbreviations CO, BR...etc
{
idx = which(xt$code == names(td)[i])
names(td)[i] = paste( xt$cancer2[idx], xt$clt[idx], sep=".")
}
length(intersect(names(facs), names(td)))
setdiff(names(facs), names(td))
## correction of names in td
names(td)[names(td) == "BR.MDAMB435"] <- "ME.MDAMB435"
names(td)[names(td) == "BR.MCF7ADR"] <- "OV.ADRRES"
setdiff(names(facs), names(td)) # only BR.MDAMB468 allowed!
#### only 59 Cell Lines in Transcriptomics data! ####
#### ---------------- proteome ####
setwd(wd)
lutp = read.table('prot_nci60_mapping.csv',header=TRUE,sep=",", as.is = TRUE, quote="");
idx = duplicated(lutp$Pnumber)
lutp = lutp[!idx,]
#### NEW FILTERED DATA HERE ####
d1=read.table("../Curate_Px_April2022/proteinGroups_esc_polished_filtered_log10.txt",header=TRUE,sep="\t", as.is = TRUE, check.names = F);
d2 <- d1
intersect(names(facs), names(d2))
length(intersect(names(facs), names(d2)))
setdiff(names(facs), names(d2)) # only "BR.MDAMB468" should appear here!!!
###################################################
### code chunk number 1: style
###################################################
BiocStyle::latex(bibstyle="unsrt")
###################################################
### code chunk number 2: load_lib_data
###################################################
library(omicade4)
data(NCI60_4arrays)
names(NCI60_4arrays)
NCI60_4arrays$hgu133p2 <- NCI60_4arrays$hgu133<- NCI60_4arrays$hgu95 <- NULL
NCI60_4arrays$FACS = facs
#NCI60_4arrays$agilent = NULL
cmn = intersect(names(facs), names(d2))
idx = grep("LOX", cmn)
cmn = cmn[-idx]
d2 = subset(d2, select = cmn)
# d2[d2==0] = NA
# idx = complete.cases(d2)
#cnts1 <- apply(d2[,1:33], 1, function(x) length(which(x>0)))
#idx = which(cnts1 > 20 )
#d4=d2[idx,]
#d4[is.na(d4)] = 0
#NCI60_4arrays$agilent = subset(NCI60_4arrays$agilent, select = cmn)
NCI60_4arrays$Px = d2
NCI60_4arrays$FACS = subset(NCI60_4arrays$FACS, select = cmn)
NCI60_4arrays$Tx = td
NCI60_4arrays$Tx = subset(NCI60_4arrays$Tx, select = cmn)
NCI60_4arrays$Px = NULL
NCI60_4arrays$FACS = NULL
NCI60_4arrays$Tx = NULL
NCI60_4arrays$Tx = td
NCI60_4arrays$Tx = subset(NCI60_4arrays$Tx, select = cmn)
NCI60_4arrays$Px = d2
NCI60_4arrays$FACS = facs
NCI60_4arrays$FACS = subset(NCI60_4arrays$FACS, select = cmn)
#head(NCI60_4arrays$agilent)
###################################################
### code chunk number 3: check_col_number
###################################################
NCI60_4arrays$agilent <-NULL
sapply(NCI60_4arrays, dim)
facs <- NCI60_4arrays$FACS
library(car)
leveneTest(unlist(lapply(facs[grep("PR", colnames(facs))], as.numeric), use.names = FALSE), unlist(lapply(facs[grep("RE", colnames(facs))], as.numeric), use.names = FALSE))
?leveneTest
Moore
hist(unlist(lapply(facs[grep("PR", colnames(facs))], as.numeric), use.names = FALSE))
hist(unlist(lapply(facs[grep("BR", colnames(facs))], as.numeric), use.names = FALSE))
hist(unlist(lapply(facs[grep("LC", colnames(facs))], as.numeric), use.names = FALSE))
hist(unlist(lapply(facs[grep("CNS", colnames(facs))], as.numeric), use.names = FALSE))
